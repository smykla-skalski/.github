---
name: Sync Files to Repository
description: >-
  Sync files from central repo to target repository, respecting per-repo config

inputs:
  token:
    description: GitHub token for API access
    required: true
  org:
    description: Organization name
    required: true
  repo:
    description: Target repository name
    required: true
  source-repo:
    description: Source repository name (where templates live)
    required: false
    default: .github
  files-config:
    description: JSON array of files to sync [{source, dest}, ...]
    required: true
  sync-config:
    description: Parsed sync-config JSON from get-sync-config action
    required: false
    default: "{}"
  dry-run:
    description: Dry run (no changes)
    required: false
    default: "false"
  branch-prefix:
    description: Prefix for sync branches
    required: false
    default: chore/org-sync
  commit-prefix:
    description: Prefix for commit messages
    required: false
    default: "chore(sync):"
  pr-labels:
    description: Comma-separated labels for PR
    required: false
    default: ci/skip-all

outputs:
  pr-url:
    description: URL of created/updated PR (empty if no changes)
    value: ${{ steps.sync.outputs.pr_url }}
  created:
    description: Number of files created
    value: ${{ steps.sync.outputs.created }}
  updated:
    description: Number of files updated
    value: ${{ steps.sync.outputs.updated }}
  deleted:
    description: Number of files deleted
    value: ${{ steps.sync.outputs.deleted }}
  skipped:
    description: Number of files skipped
    value: ${{ steps.sync.outputs.skipped }}
  excluded:
    description: Number of files excluded by config
    value: ${{ steps.sync.outputs.excluded }}
  modified-excluded:
    description: Number of files excluded due to manual modifications
    value: ${{ steps.sync.outputs.modified_excluded }}

runs:
  using: composite
  steps:
    - name: Sync files
      id: sync
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        ORG: ${{ inputs.org }}
        REPO: ${{ inputs.repo }}
        SOURCE_REPO: ${{ inputs.source-repo }}
        FILES_CONFIG: ${{ inputs.files-config }}
        SYNC_CONFIG: ${{ inputs.sync-config }}
        DRY_RUN: ${{ inputs.dry-run }}
        BRANCH_PREFIX: ${{ inputs.branch-prefix }}
        COMMIT_PREFIX: ${{ inputs.commit-prefix }}
        PR_LABELS: ${{ inputs.pr-labels }}
        GITHUB_RUN_ID: ${{ github.run_id }}
      run: |
        set -euo pipefail

        echo "üìÅ Syncing files to $ORG/$REPO..."

        # Parse sync config
        if [ -n "$SYNC_CONFIG" ] && [ "$SYNC_CONFIG" != "{}" ]; then
          sync_skip=$(echo "$SYNC_CONFIG" | jq -r '.sync.skip // false')
          files_skip=$(echo "$SYNC_CONFIG" | jq -r '.sync.files.skip // false')
          files_exclude=$(echo "$SYNC_CONFIG" | \
            jq -c '.sync.files.exclude // []')
        else
          sync_skip="false"
          files_skip="false"
          files_exclude="[]"
        fi

        # Check skip flags
        if [ "$sync_skip" = "true" ] || [ "$files_skip" = "true" ]; then
          if [ "$sync_skip" = "true" ]; then
            echo "   ‚è≠Ô∏è  Skipping: sync.skip=true in repo config"
            skip_reason="File synchronization is disabled for this repository (sync.skip=true)"
          else
            echo "   ‚è≠Ô∏è  Skipping: files.skip=true in repo config"
            skip_reason="File synchronization is disabled for this repository (files.skip=true)"
          fi

          # Check if there's an existing PR to close
          repo_sanitized="${REPO#.}"
          branch_name="${BRANCH_PREFIX}/${repo_sanitized}"
          existing_pr=$(gh pr list --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --state open \
            --json number \
            --jq '.[0].number') || existing_pr=""

          if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
            echo "   Closing PR #$existing_pr (file sync disabled)"
            gh pr close "$existing_pr" \
              --repo "$ORG/$REPO" \
              --comment "$skip_reason" \
              2>&1 || true
          fi

          echo "pr_url=" >> "$GITHUB_OUTPUT"
          echo "created=0" >> "$GITHUB_OUTPUT"
          echo "updated=0" >> "$GITHUB_OUTPUT"
          echo "skipped=0" >> "$GITHUB_OUTPUT"
          echo "excluded=0" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "   Excluded files: $files_exclude"

        # Parse files config
        files=$(echo "$FILES_CONFIG" | jq -c '.[]')

        # Track changes
        created=0
        updated=0
        skipped=0
        excluded=0
        modified_excluded=0
        deleted=0
        changes=()
        created_files=()
        updated_files=()
        modified_excluded_files=()
        deleted_files=()

        # Get default branch for target repo
        default_branch=$(gh api "repos/$ORG/$REPO" --jq '.default_branch')
        echo "   Default branch: $default_branch"

        # Get current HEAD SHA for the default branch
        base_sha=$(gh api "repos/$ORG/$REPO/git/ref/heads/$default_branch" \
          --jq '.object.sha')
        echo "   Base SHA: ${base_sha:0:7}"

        # Process each file
        while IFS= read -r file_entry; do
          [ -z "$file_entry" ] && continue

          source_path=$(echo "$file_entry" | jq -r '.source')
          dest_path=$(echo "$file_entry" | jq -r '.dest')

          echo ""
          echo "   üìÑ Processing: $dest_path"

          # Check if file is excluded
          if echo "$files_exclude" | jq -e --arg f "$dest_path" \
              'map(. == $f) | any' > /dev/null 2>&1; then
            echo "      ‚è≠Ô∏è  Excluded by config"
            excluded=$((excluded + 1))
            continue
          fi

          # Fetch source file from central repo
          api_path="repos/$ORG/$SOURCE_REPO/contents/$source_path"
          source_response=$(gh api "$api_path" 2>&1) || true

          if ! echo "$source_response" | jq -e '.content' > /dev/null 2>&1; then
            echo "      ‚ùå Source not found: $source_path"
            continue
          fi

          source_content=$(echo "$source_response" | \
            jq -r '.content' | base64 -d)
          source_sha=$(echo "$source_response" | jq -r '.sha')

          # SPECIAL CASE: renovate.json migration
          # Check for renovate config in other locations and schedule deletion
          # This runs BEFORE checking if root renovate.json exists
          if [ "$dest_path" = "renovate.json" ]; then
            echo "      üîç Checking for non-standard renovate configs..."

            for other_path in ".github/renovate.json" ".github/renovate.json5" "renovate.json5" ".renovaterc" ".renovaterc.json" ".renovaterc.json5"; do
              if gh api "repos/$ORG/$REPO/contents/$other_path" > /dev/null 2>&1; then
                echo "      üóëÔ∏è  Scheduling deletion: $other_path (migrating to root)"
                deleted=$((deleted + 1))
                deleted_files+=("$other_path")
                # Add deletion to changes
                change_json=$(jq -n --arg path "$other_path" '{path: $path, action: "delete"}')
                changes+=("$change_json")
              fi
            done
          fi

          # Fetch target file from target repo
          target_response=$(gh api "repos/$ORG/$REPO/contents/$dest_path" \
            2>&1) || true

          if echo "$target_response" | jq -e '.content' > /dev/null 2>&1; then
            # File exists - check if update needed
            target_content=$(echo "$target_response" | \
              jq -r '.content' | base64 -d)
            target_sha=$(echo "$target_response" | jq -r '.sha')

            if [ "$source_content" = "$target_content" ]; then
              echo "      ‚úì Already up to date"
              skipped=$((skipped + 1))
              continue
            fi

            # SPECIAL CASE: renovate.json - check for manual modifications
            # This file is allowed to be customized per-repo, so we detect manual
            # modifications and exclude it from sync if found.
            if [ "$dest_path" = "renovate.json" ]; then
              echo "      üîç Checking for manual modifications..."

              commits=$(gh api "repos/$ORG/$REPO/commits" \
                -f path="$dest_path" \
                -f per_page=20 \
                --jq '.[] | .commit.message' 2>&1) || commits=""

              manual_commits=$(echo "$commits" | \
                grep -v "^chore(sync):" || true)

              if [ -n "$manual_commits" ]; then
                echo "      ‚ö†Ô∏è  Manual modifications detected, excluding from sync"
                echo "      üí° Add to .github/sync-config.yml to silence this warning"
                modified_excluded=$((modified_excluded + 1))
                modified_excluded_files+=("$dest_path")
                continue
              fi
            fi

            echo "      üîÑ Needs update"
            action="update"
            updated=$((updated + 1))
            updated_files+=("$dest_path")
          else
            # File doesn't exist - create
            echo "      üÜï Will create"
            action="create"
            target_sha=""
            created=$((created + 1))
            created_files+=("$dest_path")
          fi

          # Stage change for batch commit
          # Encode content as base64 for later use (preserve trailing newline)
          encoded_content=$(echo "$source_content" | base64 | tr -d '\n')
          changes+=("$(jq -n \
            --arg path "$dest_path" \
            --arg content "$encoded_content" \
            --arg action "$action" \
            --arg sha "$target_sha" \
            '{path: $path, content: $content, action: $action, sha: $sha}')")
        done <<< "$files"

        echo ""
        echo "üìä Summary:"
        echo "   Created: $created"
        echo "   Updated: $updated"
        echo "   Deleted: $deleted"
        echo "   Skipped: $skipped (already up to date)"
        echo "   Excluded: $excluded (by repo config)"
        echo "   Modified & Excluded: $modified_excluded (manual changes detected)"

        # Output counts
        echo "created=$created" >> "$GITHUB_OUTPUT"
        echo "updated=$updated" >> "$GITHUB_OUTPUT"
        echo "deleted=$deleted" >> "$GITHUB_OUTPUT"
        echo "skipped=$skipped" >> "$GITHUB_OUTPUT"
        echo "excluded=$excluded" >> "$GITHUB_OUTPUT"
        echo "modified_excluded=$modified_excluded" >> "$GITHUB_OUTPUT"

        # If no changes, check for existing PR and close it
        if [ ${#changes[@]} -eq 0 ]; then
          echo ""
          echo "‚úÖ No changes needed"

          # Check if there's an existing PR to close
          repo_sanitized="${REPO#.}"
          branch_name="${BRANCH_PREFIX}/${repo_sanitized}"
          existing_pr=$(gh pr list --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --state open \
            --json number \
            --jq '.[0].number') || existing_pr=""

          if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
            echo "   Closing PR #$existing_pr (files are now in sync)"
            gh pr close "$existing_pr" \
              --repo "$ORG/$REPO" \
              --comment "All files are now in sync. Closing this PR." \
              2>&1 || true
          fi

          echo "pr_url=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ "$DRY_RUN" = "true" ]; then
          echo ""
          echo "üîç Dry run - no changes made"
          echo "pr_url=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo ""
        echo "üîß Creating PR with changes..."

        # Branch name - sanitize repo name (strip leading dots)
        repo_sanitized="${REPO#.}"
        branch_name="${BRANCH_PREFIX}/${repo_sanitized}"

        # Check if branch exists
        existing_branch=$(gh api "repos/$ORG/$REPO/git/ref/heads/$branch_name" \
          2>&1) || true

        if echo "$existing_branch" | jq -e '.object.sha' > /dev/null 2>&1; then
          echo "   Branch exists, will override commits..."
        else
          echo "   Creating branch: $branch_name"
          # Create branch from default branch HEAD
          gh api "repos/$ORG/$REPO/git/refs" \
            -f ref="refs/heads/$branch_name" \
            -f sha="$base_sha" > /dev/null
        fi

        # Create blobs and prepare tree entries
        echo "   Creating blobs..."
        tree_entries=()
        for change_json in "${changes[@]}"; do
          file_path=$(echo "$change_json" | jq -r '.path')
          action=$(echo "$change_json" | jq -r '.action // "update"')

          if [ "$action" = "delete" ]; then
            # For deletions, add tree entry with null sha
            echo "      Deleting: $file_path"
            tree_entries+=("$(jq -n \
              --arg path "$file_path" \
              '{path: $path, mode: "100644", type: "blob", sha: null}')")
          else
            # For creates/updates, create blob
            encoded=$(echo "$change_json" | jq -r '.content')

            blob_sha=$(gh api "repos/$ORG/$REPO/git/blobs" \
              -f content="$encoded" \
              -f encoding="base64" \
              --jq '.sha')

            tree_entries+=("$(jq -n \
              --arg path "$file_path" \
              --arg blob "$blob_sha" \
              '{path: $path, mode: "100644", type: "blob", sha: $blob}')")
          fi
        done

        # Get base tree
        base_tree=$(gh api "repos/$ORG/$REPO/git/commits/$base_sha" \
          --jq '.tree.sha')

        # Build tree JSON with all files
        tree_array=$(printf '%s\n' "${tree_entries[@]}" | jq -s '.')
        tree_json=$(jq -n \
          --arg base "$base_tree" \
          --argjson tree "$tree_array" \
          '{base_tree: $base, tree: $tree}')

        # Create single tree with all changes
        echo "   Creating tree with all changes..."
        new_tree=$(echo "$tree_json" | \
          gh api "repos/$ORG/$REPO/git/trees" --input - --jq '.sha')

        # Check if existing branch has identical content (compare file blobs)
        if echo "$existing_branch" | jq -e '.object.sha' > /dev/null 2>&1; then
          existing_sha=$(echo "$existing_branch" | jq -r '.object.sha')
          content_changed=false

          # Compare each file's blob SHA with existing branch
          for entry_json in "${tree_entries[@]}"; do
            file_path=$(echo "$entry_json" | jq -r '.path')
            new_blob=$(echo "$entry_json" | jq -r '.sha')

            # Get existing file's blob SHA from PR branch
            existing_blob=$(gh api "repos/$ORG/$REPO/contents/$file_path?ref=$branch_name" \
              --jq '.sha' 2>/dev/null) || existing_blob=""

            # Compare blobs (null for deletions means file shouldn't exist)
            if [ "$new_blob" = "null" ]; then
              if [ -n "$existing_blob" ]; then
                content_changed=true
                break
              fi
            elif [ "$new_blob" != "$existing_blob" ]; then
              content_changed=true
              break
            fi
          done

          if [ "$content_changed" = "false" ]; then
            echo "   ‚úì Branch content unchanged, skipping update"
            echo "pr_url=" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Create single commit
        commit_msg="$COMMIT_PREFIX sync organization files"
        echo "   Creating commit..."
        new_commit=$(gh api "repos/$ORG/$REPO/git/commits" \
          --input <(jq -n \
            --arg msg "$commit_msg" \
            --arg tree "$new_tree" \
            --arg parent "$base_sha" \
            '{message: $msg, tree: $tree, parents: [$parent]}') \
          --jq '.sha')

        current_sha="$new_commit"

        # Update branch ref (force-with-lease to override previous commits)
        gh api "repos/$ORG/$REPO/git/refs/heads/$branch_name" \
          -X PATCH \
          -f sha="$current_sha" \
          -F force=true > /dev/null

        echo "   Branch updated to: ${current_sha:0:7}"

        # Build PR title and body (used for both create and update)
        pr_title="chore(sync): sync organization files"

        # Build file lists for PR body
        created_list=""
        if [ ${#created_files[@]} -gt 0 ]; then
          for file in "${created_files[@]}"; do
            created_list="${created_list}- \`${file}\`"$'\n'
          done
        else
          created_list="- None"$'\n'
        fi

        updated_list=""
        if [ ${#updated_files[@]} -gt 0 ]; then
          for file in "${updated_files[@]}"; do
            updated_list="${updated_list}- \`${file}\`"$'\n'
          done
        else
          updated_list="- None"$'\n'
        fi

        # Build deleted files list
        deleted_list=""
        if [ ${#deleted_files[@]} -gt 0 ]; then
          for file in "${deleted_files[@]}"; do
            deleted_list="${deleted_list}- \`${file}\`"$'\n'
          done
        else
          deleted_list="- None"$'\n'
        fi

        # Build deleted files alert (if any deletions)
        deleted_alert=""
        if [ ${#deleted_files[@]} -gt 0 ]; then
          deleted_alert=$'\n\n> [!CAUTION]\n'
          deleted_alert="${deleted_alert}> **Files are being deleted in this sync.**"$'\n'
          deleted_alert="${deleted_alert}> "$'\n'
          deleted_alert="${deleted_alert}> The following non-standard Renovate config files are being removed"$'\n'
          deleted_alert="${deleted_alert}> in favor of the organization standard \`renovate.json\` in root:"$'\n'
          deleted_alert="${deleted_alert}> "$'\n'
          for file in "${deleted_files[@]}"; do
            deleted_alert="${deleted_alert}> - \`${file}\`"$'\n'
          done
          deleted_alert="${deleted_alert}> "$'\n'
          deleted_alert="${deleted_alert}> **This PR requires manual review before merging.**"
        fi

        # Build modified/excluded files alert
        modified_alert=""
        if [ ${#modified_excluded_files[@]} -gt 0 ]; then
          modified_alert=$'\n\n> [!IMPORTANT]\n'
          modified_alert="${modified_alert}> The following files have been manually modified and were excluded from this sync:"$'\n'
          modified_alert="${modified_alert}> "$'\n'
          for file in "${modified_excluded_files[@]}"; do
            modified_alert="${modified_alert}>   - \`${file}\`"$'\n'
          done
          modified_alert="${modified_alert}> "$'\n'
          modified_alert="${modified_alert}> To permanently exclude these files from sync, add them to \`.github/sync-config.yml\`:"$'\n'
          modified_alert="${modified_alert}> \`\`\`yaml"$'\n'
          modified_alert="${modified_alert}> sync:"$'\n'
          modified_alert="${modified_alert}>   files:"$'\n'
          modified_alert="${modified_alert}>     exclude:"$'\n'
          for file in "${modified_excluded_files[@]}"; do
            modified_alert="${modified_alert}>       - ${file}"$'\n'
          done
          modified_alert="${modified_alert}> \`\`\`"
        fi

        # Build PR body
        run_url="https://github.com/$ORG/$SOURCE_REPO/actions/runs/${GITHUB_RUN_ID}"
        pr_body="Syncs organization files from [\`$ORG/$SOURCE_REPO\`](https://github.com/$ORG/$SOURCE_REPO)."
        pr_body="${pr_body}"$'\n\n'"## Files Created"$'\n\n'"${created_list}"
        pr_body="${pr_body}"$'\n'"## Files Updated"$'\n\n'"${updated_list}"
        # Only show "Files Deleted" section if no alert (alert includes the list)
        if [ ${#deleted_files[@]} -eq 0 ]; then
          pr_body="${pr_body}"$'\n'"## Files Deleted"$'\n\n'"${deleted_list}"
        fi
        pr_body="${pr_body}${deleted_alert}"
        pr_body="${pr_body}${modified_alert}"
        pr_body="${pr_body}"$'\n\n'"---"$'\n\n'
        pr_body="${pr_body}*This PR was automatically created by the org file sync workflow "
        pr_body="${pr_body}(run [#${GITHUB_RUN_ID}](${run_url}))*"

        # Check for existing PR
        existing_pr=$(gh pr list --repo "$ORG/$REPO" \
          --head "$branch_name" \
          --state open \
          --json number,url \
          --jq '.[0]') || existing_pr=""

        if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
          # Update existing PR
          pr_number=$(echo "$existing_pr" | jq -r '.number')
          pr_url=$(echo "$existing_pr" | jq -r '.url')

          # Parse labels for update
          IFS=',' read -ra label_array <<< "$PR_LABELS"
          label_args=()
          for label in "${label_array[@]}"; do
            label_args+=(--add-label "$label")
          done

          gh pr edit "$pr_number" \
            --repo "$ORG/$REPO" \
            --title "$pr_title" \
            --body "$pr_body" \
            "${label_args[@]}" 2>&1 || true

          echo "   Updated existing PR: $pr_url"
        else

          # Parse labels
          IFS=',' read -ra label_array <<< "$PR_LABELS"
          label_args=()
          for label in "${label_array[@]}"; do
            label_args+=(--label "$label")
          done

          pr_url=$(gh pr create \
            --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --base "$default_branch" \
            --title "$pr_title" \
            --body "$pr_body" \
            "${label_args[@]}" \
            2>&1) || pr_url=""

          if [ -n "$pr_url" ]; then
            echo "   Created PR: $pr_url"
            # Extract PR number from URL
            pr_number=$(echo "$pr_url" | grep -oE '[0-9]+$')
          else
            echo "   ‚ùå Failed to create PR"
          fi
        fi

        # Enable auto-merge with squash (skip if deletions present)
        if [ -n "$pr_number" ]; then
          if [ ${#deleted_files[@]} -gt 0 ]; then
            echo "   ‚ö†Ô∏è  Skipping auto-merge (deletions require manual review)"
          else
            echo "   Enabling auto-merge (squash)..."
            pr_node_id=$(gh api "repos/$ORG/$REPO/pulls/$pr_number" \
              --jq '.node_id')

            gh api graphql \
              -f query='mutation($prId: ID!) {
                enablePullRequestAutoMerge(input: {
                  pullRequestId: $prId,
                  mergeMethod: SQUASH
                }) {
                  pullRequest {
                    autoMergeRequest {
                      enabledAt
                    }
                  }
                }
              }' \
              -f prId="$pr_node_id" > /dev/null 2>&1 || \
              echo "   ‚ö†Ô∏è  Could not enable auto-merge (may require approval or checks)"
          fi
        fi

        echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
        echo ""
        echo "‚úÖ File sync complete"
